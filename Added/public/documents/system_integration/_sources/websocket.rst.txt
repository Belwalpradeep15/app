WebSocket Protocol
==================
As of Panoptes version 13.X we have supported the WebSocket protocol. Specifically we push the necessary
information using JSON based messages over a standard WebSocket connection. While this interface was designed primarily to
communicate with
the web browsers, any software that speaks the protocol can be used to receive the same information that the browsers
receive.

**Advantages**

There are two advantages of this protocol over the others. First, it is the most efficient. Second, it is the
most complete. Because it was intended primarily for our browsers, everything that the browsers needs to display get
sent over this protocol.

**Disadvantages**

The main disadvantage is that this protocol requires the most work on the part of the client. Essentially
you have to write software that will connect to the Panoptes port, send the occasional message to it in the JSON
format, and listen for things to arrive, also in the JSON format. We do not provide libraries to assist you with this, but we
do have one we recommend that we have found useful for writing C++ based clients. We do have a client-server
simulation tool that can be used to replay messages captured from real systems, which is useful during the early stages
of development.

A second disadvantage is that this
requires communicating with the Panoptes over the TCP/IP port 57006 which may be a problem with your IT group
depending on their security policies.

Overall Protocol
----------------
When the client first connects to the server it will immediately start receiving messages. The first message it will receive is
a "Register" message from which it will need to extract the unique ID and keep track of it for future use. The next
message it will receive is an "Identity" message which will identify the server that it is connecting to. From then on it will
receive a variety of messages as the server decides to send them.

At any time the client can send a "Filter" message. This will be used to determine which messages the server will send.
Note that the "Register", "Identity" and "Heartbeat" messages cannot be turned off. They will be sent regardless of the
values in the "Filter" message. But no other messages will be sent until the "Filter" message is used to turn them on or
off.

Note that all the times used in this protocol are specified in xs:dateTime format (also known as ISO 8601) in the Zulu time
zone. Since this protocol is intended primarily for communication with other computers we have decided that it is more
desirable to always have the times in the same format rather than supplying them in different time zones.

Message Types
-------------
The following sections describe each individual message. Note that the messages come through reasonably compressed
with no spaces between items and all on a single (possibly very long) line. In this document we show them in a
somewhat more structured format to make them clearer.

Note that every message contains the keys "object_type" and "object_type_version" as a minimum.  Since 15.X, we have
introduced the "sender_uuids" field, which provides a list of system uuids that the messages have traversed through.
This is useful when you are receiving messages forwarded from other panoptes units.

Also note that the ordering of the keys is not significant and can even change from one system or even from one message
to another.

We typically bump up the version number to indicate that the message structure has changed. But, sometimes
fields can be populated only in certain configurations. So, it is not advisable to assume that a field will
always be present.

Register
^^^^^^^^
The register message is sent from the server whenever a client connects. It specifies an ID, the "unique_id" that the client
will use to identify itself to the server when necessary, in particular when submitting Filter messages.::

    {
      "object_type": "Register",
      "object_type_version": 1,
      "sender_uuids": [
        "ec72c65e-1218-11eb-ace4-080027ffd546"
      ],
      "unique_id": 4156424194
    }

Identity
^^^^^^^^
The server will send this message shortly after the Register message. It will send it again any time the identification
information is changed. This is configured via the "Admin/System Identity..." page in the Panoptes administration web
application.::

    {
      "object_type": "Identity",
      "object_type_version": 1,
      "sender_uuids": [
        "ec72c65e-1218-11eb-ace4-080027ffd546"
      ],
      "name": "swallow",
      "serial_number": "1586",
      "uuid": "ec72c65e-1218-11eb-ace4-080027ffd546",
      "custom_name": "",
      "custom_id": ""
    }

The Identity message includes (in addition to the type and version fields) the following items:

* name: The name of the Panoptes unit as defined at the factory.
* serial_number: The serial number of the Panoptes unit as defined at the factory.
* uuid: A universally unique identifier as assigned at the factory.
* custom_name: (optional) The name given to the Panoptes by the customer.
* custom_id: (optional) The id given to the Panoptes by the customer.

Heartbeat
^^^^^^^^^
The server will send heartbeats at regular intervals. (Typically every 15 seconds.) This is done in part to keep the
connection live and also so the client can determine when the Panoptes is no longer responsive.::

    {
      "object_type": "Heartbeat",
      "object_type_version": 1,
      "sender_uuids": [
        "ec72c65e-1218-11eb-ace4-080027ffd546"
      ]
    }

Filter
^^^^^^
The client sends this message to the server whenever it wants to change the messages that it receives. Note that the
Register, Identity, and Heartbeat messages will be sent regardless of the filter settings.

The "connection id" is the unique ID that was given you in the Register message.

To specify what types of objects you want to receive, place their names in a list in the "object_type_filter" key. Alternately,
you can specify a object type of "--all--" which will receive all events regardless of their type or to an empty array which
will reset to the default settings. In this case the filter type line would look like "object_type_filter": ["--
all--"].::

    {
      "object_type": "Filter",
      "object_type_version": 1,
      "object_type_filter": [
        "Event",
        "Alert"
      ],
      "connection_id_filter": [
        ""
      ],
      "exclude_if_inactive_filter": [
        ""
      ],
      "connection_id": 4156424194
    }

The messages broadcast by the server will typically reach to all clients based on the client's "object_type_filter".
However, in some cases, the "connection_id_filter" can be used to request only unicast messages from the server
for the connection_id. This feature of our protocol is not used by Panoptes units and can be ignored.

Since 15.X, the "exclude_if_inactive_filter" is also available to exclude messages that are filter for, if the panoptes
unit is inactive. This is typically used to get messages from redundant systems, where one system is at most active at
a time.

Alert
^^^^^
The alert message is sent out whenever there is a new or a change in an alert.

**Since 15.X**

The alert message includes all the details of the alert so that no extra queries are needed. This is a complex
message and its exact contents can vary based on what options have been configured.::

    {
      "object_type": "Alert",
      "object_type_version": 4,
      "sender_uuids": [
        "ec72c65e-1218-11eb-ace4-080027ffd546"
      ],
      "alert_type": "digging",
      "time": "2021-02-25T13:53:48.714Z",
      "num_properties": 0,
      "property_names": [],
      "property_values": [],
      "id": 2240538,
      "organization_id": 1,
      "resolved_flag": 0,
      "acknowledged_flag": 0,
      "deleted_flag": 0,
      "internal": {
        "uuid": "0a21f464-939d-4b45-9697-ad1c909d77b8",
        "threat_level": "red",
        "status": "new",
        "time": "2021-02-25T13:13:17Z",
        "is_suppressed": false,
        "details": {
          "alert-source": "Helios",
          "helios_unit_id": 3,
          "threatUUID": "21ac5d7c-84fd-4313-8e3a-ed8a9faeb142",
          "event_id": 76916618,
          "fibre_line_name": "Farm_Fiber_40km",
          "fibre_line_id": 5,
          "event_type": "i18n: model.event_type.description.digging",
          "position": 40500.0,
          "path_path_id": 10,
          "path_path_name": "Field Perimeter",
          "path_marker_name": "JB Marker",
          "path_distance": 281.14828699999998,
          "path_direction_of_travel": "Anti-Clockwise",
          "in_region_user": "Region_4"
        },
        "latitude": 51.257536719233201,
        "longitude": -0.918479023024247,
        "alert_responses": [
          {
            "time": "2021-02-25T13:13:17Z",
            "response": "received"
          },
          {
            "time": "2021-02-25T13:53:35Z",
            "response": "confirm"
          },
          {
            "time": "2021-02-25T13:53:38Z",
            "response": "escalate",
            "comments": "i18n: alert.comments.escalated_amber"
          },
          {
            "time": "2021-02-25T13:53:43Z",
            "response": "escalate",
            "comments": "i18n: alert.comments.escalated_red"
          }
        ]
      }
    }



The key details that are included in this message are as follows:

* id: This is the database ID of the alert.
* organization_id: If the alert can only be seen by a single organization, this will contain the organization ID. Note that this generally only applies to fibre based alerts which are only to be seen by the organization who owns the fibre. Deprecated in 15.X.
* alert_type: The name of the alert type.
* time: Creation time of the alert.
* resolved_flag: This will be set to 1 when the alert is resolved and 0 otherwise.
* acknowledged_flag: This will be set to 1 when the alert is acknowledged and 0 otherwise.
* deleted_flag: This will be set to 1 when the alert is deleted and 0 otherwise. No other information will be available when this flag is 1.

Other fields are consider to be internal and as such cannot be used.

Health
^^^^^^
The health message is sent out whenever there is a change in the system health. This message
does not contain much information. Specifically it only signifies that there has been a change in the system health. The
client program must then query the database to find the details.::

    {
        "object_type":"Health",
        "object_type_version":1,
        "sender_uuids":["ec72c65e-1218-11eb-ace4-080027ffd546"]
    }

Event
^^^^^
Event messages are sent out whenever they have been received from a Helios unit and stored in the database. You can
listen to these messages to see exactly what is being reported by the units. This is a complex message and its
exact contents can vary based on what options have been configured.::

    {
      "object_type": "Event",
      "object_type_version": 6,
      "sender_uuids": [
        "ec72c65e-1218-11eb-ace4-080027ffd546"
      ],
      "event_id": 76916627,
      "fibre_line_id": 5,
      "channel": 1,
      "event_type": "digging",
      "confidence": 0.0,
      "time": "2021-02-25T13:13:29.000Z",
      "event_track_uuid": "d40787fa-ba61-4e83-b529-adf49a508934",
      "event_track_id": 2243323,
      "application": "general",
      "amplitude": 0.0,
      "position": 40500.0390625,
      "width": 1.0,
      "velocity": 0.0,
      "acceleration": 0.0,
      "latitude": 51.257541154331498,
      "longitude": -0.91848049321549796,
      "tags": [
        {
          "tag_id": 655210962,
          "key": "distance_from_helios",
          "value": "252.325627957665",
          "units": "distance",
          "visible": true
        },
        {
          "tag_id": 655210961,
          "key": "in_region_user",
          "value": "Region_4",
          "visible": true
        },
        {
          "tag_id": 655210960,
          "key": "threatUUID",
          "value": "21ac5d7c-84fd-4313-8e3a-ed8a9faeb142"
        },
        {
          "tag_id": 655210959,
          "key": "path_velocity",
          "value": "0.343138",
          "units": "m/s"
        },
        {
          "tag_id": 655210958,
          "key": "path_direction_of_travel",
          "value": "Anti-Clockwise"
        },
        {
          "tag_id": 655210957,
          "key": "path_distance",
          "value": "280.730211",
          "units": "m"
        },
        {
          "tag_id": 655210956,
          "key": "path_marker_name",
          "value": "JB Marker"
        },
        {
          "tag_id": 655210955,
          "key": "path_path_name",
          "value": "Field Perimeter"
        },
        {
          "tag_id": 655210954,
          "key": "path_path_id",
          "value": "10"
        },
        {
          "tag_id": 655210953,
          "key": "path_acceleration",
          "value": "-0.169597",
          "units": "m/s2"
        }
      ]
    }


The following items will be found in event messages.

* event_id: The primary key assigned to the event by the database.
* fibre_line_id: The id of the fibre line on which the event was detected.
* channel: The Helios unit channel (MUX channel) corresponding to the fibre line.
* event_type: The name of the event type.
* confidence: A value between 0 and 1 defining how confident we are that the event has been properly classified.
* time: The time the event occurred.
* event_track_id: If the Helios unit determined that the event is part of a larger event track (i.e. events all grouped together) this will be the id of that track.
* event_track_uuid: Same as above, but this is the UUID actually generated by the Helios unit.
* application: Is not really meaningful any longer and should always read 'general'.
* amplitude: An indication of the loudness of the event. Note that this is not in any measurable units and can only be used to compare with other events of the same type.
* position: The position, in metres, of the centre of the event along the fibre.
* width: The width of the disturbance, in metres.
* velocity: The velocity of the disturbance, in metres/second. A negative velocity means travel towards the start of the fibre, and positive travel towards the end of the fibre.
* acceleration: The acceleration of the disturbance in metres/second^2.
* latitude/longitude: Assuming geospatial data has been configured, this will be the geospatial location of the event in decimal degrees.

**Tags**

The "tags" element is an array of optional key/value pairs that may be added based on the configuration of the system.

Each tag will contain the following items:

* tag_id: The database ID of the tag.
* key: The name of the tag. Does not need to be unique.
* value: The value of the tag. Note that this is always a string, even if it is recording a numeric value. The reader must be able to determine from the key name the meaning of the value.
* units: If present this could say 'distance' which is used to identify to our MODBUS system that this tag's value can be interpreted as a distance in metres.
* visible: If true then this tag will be displayed in the UI event popup and included in the XML messages. If false it will be considered an internal value and only accessible via this JSON message.

Testing the Protocol
--------------------
wsterm
^^^^^^
On every Panoptes and Helios system we include a command line utility called "wsterm." This utility is a useful tool for testing WebSocket connections.

To use this open up a command line terminal and type "wsterm". This will result in a brief usage message being
displayed.

In order to test the WebSocket protocol in Panoptes, type the command "wsterm ws://localhost:57006/". You will see
this connect and immediate see the "Register" and "Identity" messages. Then you will start receiving "Heartbeat"
messages. When you see a ">" prompt, that is an indication that you can type a message to send.

To send messages you type them in the console. Whatever you type is sent to the WebSocket. You will probably want to
send a "Filter" message requesting the items that you wish to receive. Since the messages you type and the messages
you receive are using the same terminal you will probably want to type your messages in another window somewhere
and cut and paste them into this terminal.

When you are done press "Cntr-C" to stop.

fotwebsocket tools
^^^^^^^^^^^^^^^^^^
We also have a collection of command line tools called the "fotwebsocket" tools. These are written in golang
and can built as standalone executables on any golang supported platform.

They include the following:

* client - which is capable of connecting to our server and printing out messages, optionally recording them if required.
* server - which is cabable of simulating a server pushing previously recorded messages.
* proxy - which is capable of simulating a server, by proxying another server.

More information about these tools is available in the "fotwebsocket" tarball.

